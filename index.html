<h1 id="unique-pointer-problems">Unique Pointer Problems</h1>
<p>When discussing Rust and safety, a common refrain is that C++ smart pointers do the same thing that Rust's do, and therefore, it's not an advantage for Rust.</p>
<p>While it's true that C++'s smart pointers are a huge leap forward, they aren't actually safe in all cases. I always forget what the exact cases are, so I made this page to remind myself.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;memory&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main ()
{
    unique_ptr&lt;<span class="dt">int</span>&gt; orig(<span class="kw">new</span> <span class="dt">int</span>(<span class="dv">5</span>));

    cout &lt;&lt; *orig &lt;&lt; endl;

    <span class="kw">auto</span> stolen = move(orig);

    cout &lt;&lt; *orig &lt;&lt; endl;
}</code></pre>
<p>The previous code, when compiled on my system (Debian Jessie):</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">g++</span> -std=c++14 -Wall -Wextra -g code.cpp -o code
$ <span class="kw">./code</span> 
<span class="kw">5</span>
<span class="kw">Segmentation</span> fault
$ <span class="kw">clang++</span> -std=c++14 -Wall -Wextra -g code.cpp -o code
$ <span class="kw">./code</span> 
<span class="kw">5</span>
<span class="kw">Segmentation</span> fault</code></pre>
<p>This happens because <code>move</code> sets <code>orig</code> to null, making this an example of undefined behavior.</p>
<p>See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">The C++11 standard</a>, section <code>20.7.1 4</code>:</p>
<blockquote>
<p>Additionally, <code>u</code> can, upon request, transfer ownership to another unique pointer <code>u2</code>. Upon completion of such a transfer, the following postconditions hold:</p>
<ul>
<li><code>u.p</code> is equal to <code>nullptr</code></li>
</ul>
</blockquote>
<p>Hence, no warning, and hence, a null pointer dereference.</p>
<p>The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pd">C++14 standard</a> uses the same language, but is in section <code>20.8.1 4</code> instead.</p>
<p>The equivalent Rust program:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="kw">let</span> org = box <span class="dv">5i</span>;

    <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, org);

    <span class="kw">let</span> stolen = org;

    <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, org);
}</code></pre>
<p>gives an error when compiled:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> code.rs
<span class="kw">code.rs</span>:8:20: 8:23 error: use of moved value: <span class="kw">`org`</span>
<span class="kw">code.rs</span>:8     println!(<span class="st">&quot;{}&quot;</span>, org);
                             ^<span class="kw">~~</span>
<span class="kw">note</span>: in expansion of format_args!
<span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:2:23: 2:77 note: expansion site
<span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 3:2 note: in expansion of println!
<span class="kw">code.rs</span>:8:5: 8:25 note: expansion site
<span class="kw">code.rs</span>:6:9: 6:15 note: <span class="kw">`org`</span> moved here because it has type <span class="kw">`Box&lt;</span>int<span class="kw">&gt;`</span>, which is moved by default
<span class="kw">code.rs</span>:6     let stolen = org<span class="kw">;</span>
                  ^<span class="kw">~~~~~</span>
<span class="kw">code.rs</span>:6:9: 6:15 help: use <span class="kw">`ref`</span> to override
<span class="kw">code.rs</span>:6     let stolen = org<span class="kw">;</span>
                  ^<span class="kw">~~~~~</span>
<span class="kw">error</span>: aborting due to previous error</code></pre>
<p>The Rust compiler itself understands move semantics, and therefore, knows that <code>org</code> is invalid after a move.</p>
<p><a href="https://news.ycombinator.com/item?id=8751815">This HN comment</a> inspired me to finally write this down.</p>
